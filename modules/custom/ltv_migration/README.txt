-- INSTALLATION --

  Install module like normal

-- CONFIGURATION --

<?php
/**
 * @file
 * Custom tokens for Metatag.
 */

/**
 * Implements hook_token_info().
 */
function metatag_token_info() {
  $info = array();

  $info['types']['metatag'] = array(
    'name' => t('Meta tags'),
    'description' => t('Generated by the Metatag module, may not be used to fill in other meta tags.'),
  );

  $metatag_info = metatag_get_info();

  foreach($metatag_info['tags'] as $value) {
    $info['tokens']['metatag'][$value['name']] = array(
      'name' => $value['label'],
      'description' => $value['description']
    );
  }

  if (module_exists('taxonomy')) {
    $info['tokens']['term']['metatag'] = array(
      'name' => t('Metatag.'),
      'description' => t('Metatag.'),
      'type' => 'metatag'
    );
  }

  if (module_exists('node')) {
    $info['tokens']['node']['metatag'] = array(
      'name' => t('Metatag.'),
      'description' => t('Metatag.'),
      'type' => 'metatag'
    );
  }

  return $info;
}

/**
 * Implements hook_tokens().
 */
function metatag_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();

  $sanitize = !empty($options['sanitize']);

  // Metatag tokens.
  if ($type == 'metatag' && !empty($data['metatag'])) {
    $metatag = $data['metatag'];
    foreach ($tokens as $name => $original) {
      if(isset($metatag[$name])){
        $replacements[$original] = $sanitize ? filter_xss($metatag[$name]) : $metatag[$name];
      }
    }
  }

  // Token tokens.
  if ($type == 'term' && !empty($data['term'])) {
    $term = $data['term'];

    if ($metatag_tokens = token_find_with_prefix($tokens, 'metatag')) {
      $result = metatag_token_generate_array($term, 'taxonomy_term', $term->vocabulary_machine_name);
      $replacements += token_generate('metatag', $metatag_tokens, array('metatag' => $result), $options);
    }
  }

  // Node tokens.
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    if ($metatag_tokens = token_find_with_prefix($tokens, 'metatag')) {
      $result = metatag_token_generate_array($node, 'node', $node->type, $metatag_tokens);
      $replacements += token_generate('metatag', $metatag_tokens, array('metatag' => $result), $options);
    }
  }

  return $replacements;
}

/**
 * Generate an array of meta tags for a given entity.
 */
function metatag_token_generate_array($entity, $entity_type, $bundle, $metatag_tokens) {
  if (metatag_entity_supports_metatags($entity_type, $bundle)) {
    $token_type = token_get_entity_mapping('entity', $entity_type);

    $instance = "{$entity_type}:{$bundle}";
    $options = array();
    $options['token data'][$token_type] = $entity;
    $options['entity'] = $entity;

    $metatags = array();
    if (!empty($entity->metatags)) {
      $language = metatag_entity_get_language($entity_type, $entity);
      if (!empty($entity->metatags[$language])) {
        $metatags = $entity->metatags[$language];
      }
    }
     dsm($metatag_tokens);
    $metatags += metatag_config_load_with_defaults($instance);

    dsm($metatags);
    // Loop through metatags to replace node metatag token
    // to it's actual node field token.
    foreach ($metatags as $metatag => $data) {
      // Explode for node metatag tokens.
      preg_match_all("^\[(.*?)\]^",$data['value'],$data_tokens, PREG_PATTERN_ORDER);
      if (!empty($data_tokens[1]) && is_array($data_tokens[1])) {
        // Loop through each token present in field.
        foreach($data_tokens[1] as $key => $value) {
          $metatag_parts = explode(':', $value);
          // Check node metatag token.
          if ($metatag_parts[0] == 'node' && $metatag_parts[1] == 'metatag') {
            unset($metatag_parts[0]); unset($metatag_parts[1]);
            $metatag_field = implode(':', $metatag_parts);
            dsm($data['value'] . '-' . $metatag_field);
            dsm($metatags[$metatag_field]['value']);
            // Field value $metatags[$metatag_field]['value'] Which may contain
            // other node metatag token that need to replace also.
            $metatag_rep_value = metatag_token_replace_nodemetatag_token($metatags, $metatags[$metatag_field]['value']);
            $metatags[$metatag]['value'] = str_replace($data_tokens[0][$key], $metatag_rep_value, $metatags[$metatag]['value']);
          }
        }
      }
    }

    $result = array();
    dsm($metatags);
    foreach ($metatags as $metatag => $data) {
      if ($metatag_instance = metatag_get_instance($metatag, $data)) {
        //$result[$metatag] = $metatag_instance->getValue($options);
      }
    }
    return $result;
  }

  return NULL;
}

function metatag_token_replace_nodemetatag_token($metatags, $token) {
  dsm('loop -' . $token);
  $metatag_rep_value = '';
  preg_match_all("^\[(.*?)\]^",$token,$data_tokens, PREG_PATTERN_ORDER);
  // Check Field has tokens.
  if (!empty($data_tokens[1]) && is_array($data_tokens[1])) {
    // Go through each token and find node metatag tokens.
    foreach($data_tokens[1] as $key => $value) {
      $metatag_parts = explode(':', $value);
      if ($metatag_parts[0] == 'node' && $metatag_parts[1] == 'metatag') {
        unset($metatag_parts[0]); unset($metatag_parts[1]);
        // Metatag field.
        $metatag_field = implode(':', $metatag_parts);
        $metatag_rep = metatag_token_replace_nodemetatag_token($metatags, $metatags[$metatag_field]['value']);
        $metatag_rep_replace[] = $metatag_rep;
      }
      else {
        $metatag_rep_replace[] = $data_tokens[0][$key];
      }
      $metatag_rep_search[] = $data_tokens[0][$key];
    }
    $metatag_rep_value .= str_replace($metatag_rep_search, $metatag_rep_replace, $token);
    
    return $metatag_rep_value;
  }
  else {
    // No tokens returns string.
    return $token;
  }
}
------ module file----------
/**
 * Replace node-metatag-token with actual node metatag field value.
 *
 * @param array $metatags
 *   A list node metatag tokens.
 * @param string $token
 *   A token need to be search and replace.
 * @param array $recursion
 *   A list of processed node metadata fields.
 *   To kept the track of fields replaced to avoid recursion.
 *
 * @return string
 *   The replaced value of token.
 */
function metatag_token_nodemetatag_replace($metatags, $token, $recursion) {
  $metatag_rep_value = '';
  preg_match_all("^\[(.*?)\]^",$token,$data_tokens, PREG_PATTERN_ORDER);
  // Check field has tokens.
  if (!empty($data_tokens[1]) && is_array($data_tokens[1])) {
    // Go through each token in field and find node-metatag-tokens.
    foreach($data_tokens[1] as $key => $value) {
      $metatag_parts = explode(':', $value);
      if ($metatag_parts[0] == 'node' && $metatag_parts[1] == 'metatag') {
        unset($metatag_parts[0]);
        unset($metatag_parts[1]);
        // Node metatag field value.
        $node_field = implode(':', $metatag_parts);
        // Check for recursion.
        if (isset($recursion[$node_field])) {
          // Set token value to blank if recursion found.
          $metatag_rep = '';
        }
        else {
          $recursion[$node_field] = array($node_field);
          $metatag_rep = metatag_token_nodemetatag_replace($metatags, $metatags[$node_field]['value'], $recursion);
        }
        $metatag_rep_replace[] = $metatag_rep;
      }
      else {
        $metatag_rep_replace[] = $data_tokens[0][$key];
      }
      $metatag_rep_search[] = $data_tokens[0][$key];
    }
    $metatag_rep_value .= str_replace($metatag_rep_search, $metatag_rep_replace, $token);

    return $metatag_rep_value;
  }
  else {
    return $token;
  }
}

----------token inc file -------------
/**
 * Loop through metatags to replace node-metatag-token
 * to it's actual node field value to avoid recursion.
 */
function metatag_token_process_nodemetatag($metatags) {
  foreach ($metatags as $metatag => $data) {
    // Explode all metatag in field.
    preg_match_all("^\[(.*?)\]^", $data['value'], $data_tokens, PREG_PATTERN_ORDER);
    if (!empty($data_tokens[1]) && is_array($data_tokens[1])) {
      foreach($data_tokens[1] as $key => $value) {
        $metatag_parts = explode(':', $value);
        // Check node-metatag-token. Like [node:metatag:<xyz>].
        if ($metatag_parts[0] == 'node' && $metatag_parts[1] == 'metatag') {
          unset($metatag_parts[0]);
          unset($metatag_parts[1]);
          $node_field = implode(':', $metatag_parts);
          // Node metatag field may contain other node-metatag-token
          // that need to be replace too.
          $recursion[$node_field] = array($node_field);
          $metatag_rep_value = metatag_token_nodemetatag_replace($metatags, $metatags[$node_field]['value'], $recursion);
          $metatags[$metatag]['value'] = str_replace($data_tokens[0][$key], $metatag_rep_value, $metatags[$metatag]['value']);
        }
      }
    }
  }

  return $metatags;
}

    // Process it for node metatag replacement to avoid infanite recursion.
    $metatags = metatag_token_process_nodemetatag($metatags);
================================================================================================================
---module file----

/**
 * Loop through metatags to replace node-metatag-token
 * to it's actual node field value to avoid recursion.
 */
function metatag_token_process_nodemetatag($metatags) {
  // Find entities which have metatag enabled.
  $entities = entity_get_info();
  $metatag_entities = array();
  foreach ($entities as $entity) {
    if (isset($entity['metatags']) && $entity['metatags']) {
      $metatag_entities[$entity['token type']] = $entity['token type'];
    }
  }

  foreach ($metatags as $metatag => $data) {
    // Explode all metatag in field.
    preg_match_all("^\[(.*?)\]^", $data['value'], $data_tokens, PREG_PATTERN_ORDER);
    if (!empty($data_tokens[1]) && is_array($data_tokens[1])) {
      foreach($data_tokens[1] as $key => $value) {
        $metatag_parts = explode(':', $value);
        // Check node-metatag-token. Like [node:metatag:<xyz>].
        if (isset($metatag_entities[$metatag_parts[0]]) && $metatag_parts[1] == 'metatag') {
          unset($metatag_parts[0]);
          unset($metatag_parts[1]);
          $entity_field = implode(':', $metatag_parts);
          // Node metatag field may contain other node-metatag-token
          // that need to be replace too.
          $recursion[$entity_field] = array($entity_field);
          $metatag_rep_value = metatag_token_nodemetatag_replace($metatags, $metatags[$entity_field]['value'], $metatag_entities, $recursion);
          $metatags[$metatag]['value'] = str_replace($data_tokens[0][$key], $metatag_rep_value, $metatags[$metatag]['value']);
        }
      }
    }
  }

  return $metatags;
}

    // Process it for node metatag replacement to avoid infanite recursion.
    $metatags = metatag_token_process_nodemetatag($metatags);
    
  ----token.module----
  /**
 * Replace node-metatag-token with actual node metatag field value.
 *
 * @param array $metatags
 *   A list node metatag tokens.
 * @param string $token
 *   A token need to be search and replace.
 * @param array $metatag_entities
 *   A list of entities which have metatag enabled.
 * @param array $recursion
 *   A list of processed node metadata fields.
 *   To kept the track of fields replaced to avoid recursion.
 *
 * @return string
 *   The replaced value of token.
 */
function metatag_token_nodemetatag_replace($metatags, $token, $metatag_entities, $recursion) {
  dsm('loop - ' . $token);
  $metatag_rep_value = '';
  preg_match_all("^\[(.*?)\]^",$token,$data_tokens, PREG_PATTERN_ORDER);
  // Check field has tokens.
  if (!empty($data_tokens[1]) && is_array($data_tokens[1])) {
    // Go through each token in field and find node-metatag-tokens.
    foreach($data_tokens[1] as $key => $value) {
      $metatag_parts = explode(':', $value);
      if (isset($metatag_entities[$metatag_parts[0]]) && $metatag_parts[1] == 'metatag') {
        unset($metatag_parts[0]);
        unset($metatag_parts[1]);
        // Node metatag field value.
        $entity_field = implode(':', $metatag_parts);
        // Check for recursion.
        if (isset($recursion[$entity_field])) {
          // Set token value to blank if recursion found.
          $metatag_rep = '';
        }
        else {
          $recursion[$entity_field] = array($entity_field);
          $metatag_rep = metatag_token_nodemetatag_replace($metatags, $metatags[$entity_field]['value'], $metatag_entities, $recursion);
        }
        $metatag_rep_replace[] = $metatag_rep;
      }
      else {
        $metatag_rep_replace[] = $data_tokens[0][$key];
      }
      $metatag_rep_search[] = $data_tokens[0][$key];
    }
    $metatag_rep_value .= str_replace($metatag_rep_search, $metatag_rep_replace, $token);

    return $metatag_rep_value;
  }
  else {
    return $token;
  }
}
===========================================
  $text_tokens = token_scan($text);
  if (isset($text_tokens[$token_type])) {
    $metatags = $metatag_rep_search = $metatag_rep_replace = array();
    foreach ($text_tokens[$token_type] as $key => $tokens) {
      $entity = $data[$token_type];
      $bundle = $entity->type;
      $instance = "{node}:{$bundle}";
      if (!empty($entity->metatags)) {
        $language = metatag_entity_get_language('node', $entity);
        if (!empty($entity->metatags[$language])) {
          $metatags = $entity->metatags[$language];
        }
      }
      $metatags += metatag_config_load_with_defaults($instance);
      // Check node-metatag-token. Like [node:metatag:<xyz>].
      $metatag_parts = explode(':', $tokens);
      if ($metatag_parts[1] == 'metatag') {
        $metatag_rep_search[] = $tokens;
        $metatag_rep_replace[] = metatag_token_entitymetatagtoken_replace($metatags, $tokens, $token_type);
      }
    }
    $text = str_replace($metatag_rep_search, $metatag_rep_replace, $text);
  }
